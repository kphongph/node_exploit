#include <node.h>
#include <pcap.h>
#include "pcap_handler.h"

using namespace v8;

PcapHandler::PcapHandler() {
}

PcapHandler::~PcapHandler() {
}

void PcapHandler::Init(Handle<Object> exports) {
  Local<FunctionTemplate> tpl = FunctionTemplate::New(New);
  tpl->SetClassName(String::NewSymbol("PcapHandler"));
  tpl->InstanceTemplate()->SetInternalFieldCount(1);
  // prototype
  tpl->PrototypeTemplate()->Set(String::NewSymbol("open"),
     FunctionTemplate::New(Open)->GetFunction());
  Persistent<Function> constructor;
  constructor = Persistent<Function>::New(tpl->GetFunction());
  exports->Set(String::NewSymbol("PcapHandler"),constructor);
}

void PcapHandler::PacketReady(u_char *s,const struct pcap_pkthdr* pkthdr, 
   const u_char* packet) {
  HandleScope scope;
  PcapHandler* handler = (PcapHandler *)s;
  printf("packet ready!!\n");

  Local<Value> argv[1] = {Number::New(1)};
  handler->packet_callback_fn->Call(Context::GetCurrent()->Global(),1,argv);
}

Handle<Value> PcapHandler::New(const Arguments& args) {
  HandleScope scope;
  PcapHandler* obj = new PcapHandler();
  obj->Wrap(args.This());
  return args.This();
}


Handle<Value> PcapHandler::Open(const Arguments& args) {
  HandleScope scope;
  pcap_t *handle;
  char errbuf[PCAP_ERRBUF_SIZE];

  printf("Open\n");
  String::Utf8Value device(args[0]->ToString());
  handle=pcap_open_live((char *)*device,BUFSIZ,1,100000,errbuf);
  
  if(handle==NULL) {
    return scope.Close(Undefined());
  } else {
    PcapHandler* obj = ObjectWrap::Unwrap<PcapHandler>(args.This());

    obj->packet_callback_fn = Persistent<Function>::New(
       Handle<Function>::Cast(args[1]));
    
    int packet_count;
    do {
      packet_count= pcap_dispatch(handle,1,PacketReady,(u_char *)obj);
      printf("packet count = %d\n",packet_count);
    } while(packet_count > 0);

    printf("ok 2\n");
    return scope.Close(Integer::NewFromUnsigned(packet_count));
  }
}

